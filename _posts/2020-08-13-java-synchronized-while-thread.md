Java中一个线程执行死循环有什么后果:
web link: https://www.jb51.net/article/84211.htm

[1] 由于线程A和线程B获得的对象锁不是同一把锁，从结果中可以看出，线程B是可以执行完成的。而线程A由于进入了while死循环，故线程A一直执行运行下去了(整个程序未结束)，但线程B会结束。

也就是说，尽管线程A一直在while中执行，需要占用CPU。但是，线程的调度是由JVM或者说是操作系统来负责的，并不是说线程A一直在while循环，然后线程B就占用不到CPU了。对于线程A而言，它就相当于一个“计算密集型”作业了。如果我们的while循环是不断地测试某个条件是否成立，那么这种方式就很浪费CPU，可参考一个具体的实例：JAVA多线程之线程间的通信方式 中的“线程间的通信方式”第二点while轮询。

[2] 如果把Service.java修改成如下： synchronized (this)

若线程A先获得对象锁时，由于while循环，线程A一直在while空循环中。而线程B也因为无法获得锁而执行不了methodB()。

可以看出，如果在一个线程在synchronized方法中无法退出，无法将锁释放，另一个线程就只能无限等待了。
